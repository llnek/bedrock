/*??
 * COPYRIGHT (C) 2012 CHERIMOIA LLC. ALL RIGHTS RESERVED.
 *
 * THIS IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
 * MODIFY IT UNDER THE TERMS OF THE APACHE LICENSE,
 * VERSION 2.0 (THE "LICENSE").
 *
 * THIS LIBRARY IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS
 * AND LIMITATIONS UNDER THE LICENSE.
 *
 * You should have received a copy of the Apache License
 * along with this distribution; if not, you may obtain a copy of the
 * License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 ??*/

package com.zotoh.fwk.db

import scala.collection.mutable.HashMap

import com.zotoh.fwk.util.CoreUte._
import com.zotoh.fwk.io.IOUte._

import java.io.{ByteArrayOutputStream=>BAOS}
import java.io.File
import java.sql.Connection
import java.sql.SQLException
import java.sql.Statement


import com.zotoh.fwk.util.FileUte

import org.scalatest.Assertions._
import org.scalatest._


class FwkDbJUT  extends FunSuite with BeforeAndAfterEach with BeforeAndAfterAll {

  override def beforeAll(configMap: Map[String, Any]) {
  }

  override def afterAll(configMap: Map[String, Any]) {
    FileUte.purgeDir( new File(_dbDir))
  }

  override def beforeEach() { }

  override def afterEach() { }


  private val SQL="""
CREATE CACHED TABLE star (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
firstname VARCHAR(20),
lastname VARCHAR(20))
-- :
INSERT INTO star (id, firstname, lastname) VALUES (DEFAULT, 'Felix', 'the Cat')
"""

  private val _dbDir=niceFPath( genTmpDir())

  private val _dbID="test007"
  private val _user="zeus"
  private val _pwd="zeus123"

  test("testCreateH2DB") {
    val path= _dbDir+ "/"+ _dbID
    H2DBSQL.createDatabase( Array(
        "-create:"+path,
        "-user:" + _user,
        "-pwd:" + _pwd
    ))
    assert(H2DB.existsDB(path))
  }

  test("testCreateH2WithSQL") {
    val f= new File( _dbDir+"/" + uid() + ".sql")
    writeFile(f, SQL)
    val path= _dbDir+ "/"+ _dbID
    try {
      H2DBSQL.createDatabase( Array(
          "-create:"+ path,
          "-user:" + _user,
          "-pwd:"+ _pwd,
          "-sql:"+ f.getCanonicalPath()
      ))
    } finally {
      f.delete()
    }
    assert(H2DB.existsDB(path))
  }

  test("testLoadH2WithSQL") {
    val f= new File( _dbDir+"/" + uid() + ".sql")
    writeFile(f, SQL)
    val path= _dbDir+ "/"+ _dbID

    try {
      val url = H2DBSQL.createDatabase( Array(
          "-create:"+path,
          "-user:"+_user,
          "-pwd:"+_pwd
      ))
      H2DBSQL.createDatabase( Array(
          "-url:"+url,
          "-user:"+_user,
          "-pwd:"+_pwd,
          "-sql:"+f.getCanonicalPath()
      ))
    } finally {
      f.delete()
    }
    assert(H2DB.existsDB(path))
  }

  test("testDBRow") {
    val m= HashMap[String,Any]()
    var r = DbRow("table1")
    expect(r.sqlTable())( "table1")
    m += "c1" -> 25
    r= DbRow().add(m.toMap)
    assert(r.exists("c1"))
    expect(r.get("c1").get)( 25)
    r= DbRow("t1")
    m += "c1" -> 33
    r.add(m.toMap)
    expect(r.get("c1").get)( 33)
    expect(r.values().size)( r.size())
    r.clear()
    assert(r.isEmpty())
    m += "c1" -> 99
    r= DbRow().add(m.toMap)
    expect(r.remove("c1").get)( 99)
    expect(r.size())(0)
  }

  test("testMemDB") {
    val url= H2DB.mkMemDB(_dbID, _user, _pwd)
    assert( url != null && url.length() > 0)
  }

  test("testLoadDDL") {
    val url= H2DB.mkMemDB("aaa", _user, _pwd)
    try {
      DDLUte.loadDDL( JDBCInfo(url, _user, _pwd), getDDLStr())
      assert(true)
    } catch {
      case _ => assert(false, "loadddl failed")
    }
    // no errors assume works :)
  }

  private def getDDLStr() = {
    val baos= new BAOS()
    DDLUte.ddlToStream(baos, "com/zotoh/fwk/db/ddl.sql")
    asString(baos.toByteArray() )
  }

  test("testJDBC") {

    val dbUrl= H2DB.mkMemDB(_dbID, _user, _pwd)
    val j= JDBCInfo(dbUrl, _user, _pwd)
    
    if (!DBUte.tableExists(j, "user_accounts")) {
      DDLUte.loadDDL(j, getDDLStr())      
    }

    assert( DBUte.tableExists(j, "user_accounts")) 
    
    val pm= new JDBCPoolMgr()
    assert( !pm.existsPool("x"))
    var pp= pm.mkPool("x", j)
    assert(pp != null)
    assert(pm.existsPool("x"))
    pp= pm.getPool("x").get
    assert(pp != null)

    var jj= pp.newJdbc()
    var m= jj.getTableMetaData("user_accounts")
    expect(m.size)(14)
    expect(0)( jj.countRows("user_accounts"))

    // insert
    var r= DbRow("user_accounts")
    r.add("user_id", "id1")
    expect( 1)( jj.insertOneRow(r))

    // update
    r.clear()
    r.add("user_role", "admin")
    expect(1)( jj.updateOneRow(r, "user_id=?", Array("id1") ))

    // select
    var s = SELECTStmt.simpleQry("user_accounts")
    r=jj.fetchOneRow(s).get
    assert(r != null && r.size()==14)

    s= new SELECTStmt("select * from user_accounts where user_id=?",
        Array("id1") )
    r=jj.fetchOneRow(s).get
    assert( r != null && r.size()==14)

    s= new SELECTStmt("select * from user_accounts where user_id='id1' ")
    r=jj.fetchOneRow(s).get
    assert(r!=null && r.size()==14)

    s= new SELECTStmt("user_role", "user_accounts")
    r=jj.fetchOneRow(s).get
    assert(r != null && r.size()==1)

    s= new SELECTStmt("user_role", "user_accounts", "user_id=?",
        Array("id1") )
    r=jj.fetchOneRow(s).get
    assert(r != null && r.size()==1)

    s= new SELECTStmt("user_role,user_id", "user_accounts", "user_id=?", "order by user_role",
        Array("id1") )
    r=jj.fetchOneRow(s).get
    assert(r != null && r.size()==2)

    assert(jj.existRows("user_accounts"))
    assert(jj.existRows("user_accounts", "user_id=?",
          Array("id1") ))

    expect(1)(jj.countRows("user_accounts" ))
    expect(1)(jj.countRows("user_accounts", "user_id=?", Array("id1")))

    // delete
    var d= DELETEStmt.simpleDelete("user_accounts")
    expect(1)(jj.deleteRows(d))

    d=new DELETEStmt("delete from user_accounts where user_id=?",
        Array("id1") )
    expect(0)(jj.deleteRows(d))

    d=new DELETEStmt("delete from user_accounts where user_id='id1' ")
    expect(0)(jj.deleteRows(d))

    d= new DELETEStmt("user_accounts", "user_id=?" , Array("id1") )
    expect(0)(jj.deleteRows(d))

    d= new DELETEStmt("user_accounts", "user_id='id1' ", Array[Any]() )
    expect(0)(jj.deleteRows(d))

    assert(! jj.existRows("user_accounts"))
  }

  test("testUte") {
    val jp= JDBCInfo("jdbc:h2:mem:xxx;DB_CLOSE_DELAY=-1", _user, _pwd)
    using(DBUte.createConnection(jp)) { (c) =>
      assert(c != null)
      assert( !DBUte.tableExists(jp, "xyz"))
      using(c.createStatement()) { (stmt) =>
        try {
          stmt.executeUpdate("create table xyz ( fname varchar(255))")
        } catch {
          case _ => assert(false, "load-ddl-failed")
        }
      }
    }

    try {DBUte.testConnection(jp) } catch {
      case _ => assert(false,"unexpected error")
    }

    var v=DBUte.vendor(jp)
    expect(v)( DBVendor.H2)
    assert(DBUte.loadDriver("org.h2.Driver") != null)
    assert(DBUte.tableExists(jp, "xyz"))
    assert(! DBUte.rowExists(jp, "xyz"))

    using(DBUte.createConnection(jp)) { (c) =>
      using(c.createStatement()) { (stmt) =>
        try {
          stmt.executeUpdate("insert into xyz values('jerry')")
        } catch {
          case _ => assert(false,"load-ddl-failed")
        }
      }
    }

    assert(DBUte.rowExists(jp, "xyz"))
    expect( DBUte.firstRow(jp, "select * from xyz").get.size())(1)
  }

  test("testTransaction") {
    var jp= JDBCInfo("jdbc:h2:mem:zzz;DB_CLOSE_DELAY=-1", _user, _pwd)
    using(DBUte.createConnection(jp)) { (c) =>
      assert(c != null)
      using(c.createStatement()) { (stmt) =>
        try {
          stmt.executeUpdate("create table xyz ( fname varchar(255))")
        } catch {
          case _ => assert(false,"load-ddl-failed")
        }
      }
    }
    val pm= new JDBCPoolMgr()
    val p=pm.mkPool(jp)
    val j= p.newJdbc()
    var r= DbRow("xyz")
    var jc= j.beginTX()
    r.add("fname", "jerry")
    j.insertOneRow(jc, r)
    j.cancelTX(jc)
    j.closeTX(jc)
    assert(!DBUte.rowExists(jp, "xyz"))

    jc= j.beginTX()
    r.add("fname", "jerry")
    j.insertOneRow(jc, r)
    j.commitTX(jc)
    j.closeTX(jc)
    assert(DBUte.rowExists(jp, "xyz"))

  }

}
