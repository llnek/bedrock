/*??
 * COPYRIGHT (C) 2012 CHERIMOIA LLC. ALL RIGHTS RESERVED.
 *
 * THIS IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
 * MODIFY IT UNDER THE TERMS OF THE APACHE LICENSE,
 * VERSION 2.0 (THE "LICENSE").
 *
 * THIS LIBRARY IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS
 * AND LIMITATIONS UNDER THE LICENSE.
 *
 * You should have received a copy of the Apache License
 * along with this distribution; if not, you may obtain a copy of the
 * License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 ??*/

package com.zotoh.bedrock.device

import scala.collection.mutable.HashMap

import com.zotoh.fwk.util.CoreUte._
import com.zotoh.fwk.util.StrUte._
import com.zotoh.fwk.io.XData
import com.zotoh.fwk.util.{CoreImplicits,StrArr}
import com.zotoh.bedrock.http.UriPathChain

/**
 * An event generated by HTTP device(s).  In some cases, this acts
 * as the base class for other events generated by HTTP derived devices.
 *
 * @author kenl
 */
class HttpEvent(dev:Device) extends Event(dev) with CoreImplicits {

  private val serialVersionUID = 4177245480803037339L

  private val _params= HashMap[String,StrArr]()
  private val _hdrs= HashMap[String,String]()
  private val _attrs= HashMap[String,Any]()

  private var _servletPath=""
  private var _url=""
  private var _uri= ""
  private var _queryString=""
  private var _method= ""

  private var _ctype=""
  private var _remoteAddr=""
  private var _remoteHost=""
  private var _localAddr=""
  private var _localHost=""
  private var _protocol=""
  private var _server=""
  private var _scheme=""

  private var _remotePort=0
  private var _localPort=0
  private var _serverPort=0
  private var _ssl=false

  private var _data:XData=null
  private var _cLen=0L

  /**
   * @param c
   * @return
   */
  def setUriChain(c:UriPathChain) = false

  /**
   * @param s
   */
  def setData(s:XData) { _data=s }

  /**
   * @return
   */
  def data() = _data

  /**
   * @param len
   */
  def setContentLength(len:Long) { _cLen = len  }

  /**
   * Get the <i>content-length</i>.
   *
   * @return long.
   */
  def contentLength() = _cLen

  /**
   * @param type
   */
  def setContentType(ct:String) = {
    _ctype = nsb(ct)
    this
  }

  /**
   * @param n
   * @param v
   */
  def addAttr(n:String, v:Any) = {
    if ( ! isEmpty(n)) {
      _attrs += Tuple2(n,v)
    }
    this
  }

  /**
   * Get the <i>content-type</i> of the request.
   *
   * @return String.
   */
  def contentType() = _ctype

  /**
   * Get all the internet headers from the request.
   *
   * @return immutable Map.
   */
  def headers() = _hdrs.toMap

  /**
   * Overwrites existing one if same.
   *
   * @param hdr
   * @param value
   */
  def setHeader(hdr:String, v:String) {
    if ( !isEmpty(hdr))
    { _hdrs += Tuple2(hdr, nsb(v)) }
  }

  /**
   * Get the value for this header.
   *
   * @param nm header string.
   * @return value or null.
   */
  def header(nm:String) = {
    if (isEmpty(nm)) null else _hdrs.find{(t)=>
      t._1.eqic(nm)
    } match {
      case Some(x) => x._2
      case _ => null
    }
  }

  /**
   * @param addr
   */
  def setLocalAddr(addr:String) = { _localAddr= nsb(addr); this }

  /**
   * Get the <i>Local-Addr</i> from the request.
   *
   * @return String.
   */
  def localAddr() = _localAddr

  /**
   * @param host
   */
  def setLocalHost(host:String) = { _localHost= nsb(host) ; this }

  /**
   * Get the <i>Local Host</i> from the request.
   *
   * @return String.
   */
  def localHost()= _localHost

  /**
   * @param port
   */
  def setLocalPort(port:Int) = { _localPort= port; this }

  /**
   * Get the <i>Local Port</i> from the request.
   *
   * @return int.
   */
  def localPort() = _localPort

  /**
   * @param method
   */
  def setMethod(m:String) = { _method= nsb(m); this }

  /**
   * Get the <i>Method</i> from the request.
   *
   * @return String.
   */
  def method() = _method

  /**
   * @return
   */
  def params() = _params.toMap

  /**
   * @param p
   * @return
   */
  def param(p:String) = {
    if (isEmpty(p)) None else _params.find { (t) =>
      t._1.eqic(p)
    } match {
      case Some(x) => Some(x._2)
      case _ => None
    }
  }

  /**
   * Get the set of <i>Attributes</i> from the request.
   *
   * @return immutable Map.
   */
  def attrs() = _attrs.toMap

  /**
   * @param p
   * @param values
   */
  def addParam(p:String, vs:Seq[String]):HttpEvent = {
    if ( !isEmpty(p)) {
      if (vs != null) for ( i <- 0 until vs.length) {
        addParam(p, vs(i))
      }
    }
    this
  }

  /**
   * @param p
   * @param value
   */
  def addParam(p:String, v:String):HttpEvent = {
    val r= param(p) match {
      case Some(s) => s
      case _ =>
        val r= StrArr()
        _params += Tuple2(p, r)
        r
    }
    r.add(nsb(v))
    this
  }

  /**
   * @param p
   */
  def setProtocol(p:String) =  { _protocol= nsb(p); this }

  /**
   * Get the <i>Protocol</i> from the request.
   *
   * @return String.
   */
  def protocol() = _protocol

  /**
   * @param q
   */
  def setQueryString(q:String) = { _queryString= nsb(q) ; this }

  /**
   * Get the <i>Query String</i> from the request.
   *
   * @return String.
   */
  def queryString() =  _queryString

  /**
   * @param addr
   */
  def setRemoteAddr(addr:String) = {  _remoteAddr= nsb(addr) ; this }

  /**
   * Get the <i>Remote Addr</i> from the request.
   *
   * @return String.
   */
  def remoteAddr() =  _remoteAddr

  /**
   * @param host
   */
  def setRemoteHost(host:String) = { _remoteHost= nsb(host); this  }

  /**
   * Get the <i>Remote Host</i> from the request.
   *
   * @return String.
   */
  def remoteHost() = _remoteHost

  /**
   * @param port
   */
  def setRemotePort(port:Int) = {   _remotePort= port ; this }

  /**
   * Get the <i>Remote Port</i> from the request.
   *
   * @return Integer
   */
  def remotePort() = _remotePort

  /**
   * @param scheme
   */
  def setScheme(scheme:String) = { _scheme= nsb(scheme) ; this }

  /**
   * Get the <i>Scheme</i> from the request.
   *
   * @return String.
   */
  def scheme() = _scheme

  /**
   * @param server
   */
  def setServer(server:String) = { _server= nsb(server); this  }

  /**
   * Get the <i>Server</i> from the request.
   *
   * @return String.
   */
  def server() = _server

  /**
   * @param port
   */
  def setServerPort(port:Int) = { _serverPort= port ; this }

  /**
   * Get the <i>Server Port</i> from the request.
   *
   * @return Integer.
   */
  def serverPort() = _serverPort

  /**
   * @param path
   */
  def setServletPath(path:String) =  { _servletPath= path ; this }

  /**
   * Get the <i>Servlet Path</i> from the request.
   *
   * @return String.
   */
  def servletPath() = _servletPath

  /**
   * @param ssl
   */
  def setSSL(ssl:Boolean) = {
    _ssl= ssl
    setScheme( if(ssl) "https" else "http")
  }

  /**
   * Check if the listener was SSL.
   *
   * @return true if SSL.
   */
  def isSSL() = _ssl

  /**
   * @param uri
   */
  def setUri(uri:String) = { _uri= nsb(uri) ; this }

  /**
   * Get the <i>URI</i> from the request.
   *
   * @return String.
   */
  def uri() = _uri

  /**
   * @param url
   */
  def setUrl(url:String) = { _url= nsb(url); this  }

  /**
   * Get the actual <i>URL</i> from the request.
   *
   * @return
   */
  def url() = _url

  /* (non-Javadoc)
   * @see java.lang.Object#toString()
   */
  override def toString() = {
    var bf= "" +
    "servlet-path=" + _servletPath + ", " +
    "url=" + _url + ", " +
    "uri=" + _uri + ", " +
    "queryString=" + _queryString + ", " +
    "method=" + _method + ", " +
    "ctype=" + _ctype + ", " +
    "clen=" + _cLen + ", " +
    "remote-addr=" + _remoteAddr + ", " +
    "remote-host=" + _remoteHost + ", " +
    "remote-port=" + _remotePort + ", " +
    "local-addr=" + _localAddr + ", " +
    "local-host=" + _localHost + ", " +
    "local-port=" + _localPort + ", " +
    "protocol=" + _protocol + ", " +
    "server=" + _server + ", " +
    "serverPort=" + _serverPort + ", " +
    "scheme=" + _scheme + ", " +
    "ssl=" + _ssl + "\n" +
    "data=" +
    (if(_data==null) "null" else if (_data.isDiskFile()) _data.filePath() else "byte[]")  +
     "\n"

    var ts="\n"
    _params.foreach{ (t) => ts += t._1 + "=[" + t._2.toString() + "]" }
    bf += "params=" + ts + "\n"
    ts="\n"
    _hdrs.foreach{ (t) => ts += t._1 + ": " + t._2.toString() + "\n" }
    bf += "headers=" + ts + "\n"
    bf
  }

}

